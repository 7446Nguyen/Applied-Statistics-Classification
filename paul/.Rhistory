)
flattenCorrMatrix <- function(cormatrix, pmatrix) {
ut <- upper.tri(cormatrix)
data.frame(
row = rownames(cormatrix)[row(cormatrix)[ut]],
column = rownames(cormatrix)[col(cormatrix)[ut]],
cor  =(cormatrix)[ut],
p = pmatrix[ut]
)
}
options(scipen=999)
options(max.print=100000)
#See what variables are correlated with eachother, p-values
correlation.matrix <- Hmisc::rcorr(as.matrix(df.numeric), type="pearson")
corDF <- data.frame(flattenCorrMatrix(correlation.matrix$r, correlation.matrix$P))
corDF.ordered <- data.frame(corDF[order(-corDF$cor),])
collinear.correlation <- corDF[which(corDF$cor >= 0.75),]
collinear.correlation <- data.frame(collinear.correlation[order(-collinear.correlation$cor),])
#write.csv(colinear.correlation, "Collinear_Correlation_Matrix.csv")
#write.csv(corDF.ordered, "All_Vars_Correlation_Matrix.csv")
qda(shot_made_flag ~ ., CV=T, data=df.numeric)
df.numeric
str(df.numeric)
unique(df.numeric$playoffs)
str(df.numeric)
df[order(df$shot_made_flag),]
df.numeric <- df.numeric[order(df.numeric$shot_made_flag),]
qda(shot_made_flag ~ ., CV=T, data=df.numeric)
flattenCorrMatrix <- function(cormatrix, pmatrix) {
ut <- upper.tri(cormatrix)
data.frame(
row = rownames(cormatrix)[row(cormatrix)[ut]],
column = rownames(cormatrix)[col(cormatrix)[ut]],
cor  =(cormatrix)[ut],
p = pmatrix[ut]
)
}
options(scipen=999)
options(max.print=100000)
#See what variables are correlated with eachother, p-values
correlation.matrix <- Hmisc::rcorr(as.matrix(df.numeric), type="pearson")
corDF <- data.frame(flattenCorrMatrix(correlation.matrix$r, correlation.matrix$P))
corDF.ordered <- data.frame(corDF[order(-corDF$cor),])
collinear.correlation <- corDF[which(corDF$cor >= 0.75),]
collinear.correlation <- data.frame(collinear.correlation[order(-collinear.correlation$cor),])
#write.csv(colinear.correlation, "Collinear_Correlation_Matrix.csv")
#write.csv(corDF.ordered, "All_Vars_Correlation_Matrix.csv")
flattenCorrMatrix <- function(cormatrix, pmatrix) {
ut <- upper.tri(cormatrix)
data.frame(
row = rownames(cormatrix)[row(cormatrix)[ut]],
column = rownames(cormatrix)[col(cormatrix)[ut]],
cor  =(cormatrix)[ut],
p = pmatrix[ut]
)
}
options(scipen=999)
options(max.print=100000)
#See what variables are correlated with eachother, p-values
correlation.matrix <- Hmisc::rcorr(as.matrix(df.numeric), type="pearson")
corDF <- data.frame(flattenCorrMatrix(correlation.matrix$r, correlation.matrix$P))
corDF.ordered <- data.frame(corDF[order(-corDF$cor),])
collinear.correlation <- corDF[which(corDF$cor >= 0.75),]
collinear.correlation <- corDF[which(corDF$cor >= 0.75),]
collinear.correlation
df <- df %>% subset(select=-c(lat, # dropping lat because it is collinear with loc_y and shot_distance
lon, # dropping lon because it is collinear with loc_x and shot_distance
period, # dropping period in favor of game event id because game event id is more descriptive and continuous
playoffs # dropping playoffs for game_id; game ID can capture playoffs seasonally
)
)
df.numeric <- df %>% keep(is.numeric)
options(scipen=999)
options(max.print=100000)
#See what variables are correlated with eachother, p-values
correlation.matrix <- Hmisc::rcorr(as.matrix(df.numeric), type="pearson")
corDF <- data.frame(flattenCorrMatrix(correlation.matrix$r, correlation.matrix$P))
corDF.ordered <- data.frame(corDF[order(-corDF$cor),])
collinear.correlation <- corDF[which(corDF$cor >= 0.75),]
collinear.correlation <- data.frame(collinear.correlation[order(-collinear.correlation$cor),])
collinear.correlation
collinear.correlation <- corDF[which(corDF$cor >= 0.50),]
collinear.correlation <- data.frame(collinear.correlation[order(-collinear.correlation$cor),])
collinear.correlation
Bartlett_ChiSq <- rrcov::Wilks.test(shot_made_flag ~ ., data=df.numeric, method = "c", approximation = "Bartlett")
# Wilk's Lambda produces significant p-value in Bartlett's test so we need to use a Quadratic Discriminant Analysis instead of Linear
format(round(Bartlett_ChiSq$p.value, 2), nsmall=4)
# Wilks' Lambda plus degrees of freedom used in Bartlett's chi-squared test
WilksDegreesofFreedom <- rbind(as.numeric(paste0(Bartlett_ChiSq$parameter, sep = " ")))
# p-value from Bartlett's test
Bartlett_ChiSq$p.value
Bartletts_p <- format(round(as.numeric(Bartlett_ChiSq$p.value), 2), nsmall=4)
# Because Bartlett's p-value is less than 1, updating to shorter form:
Bartletts_p <- "p < 0.0001"
dfBartlett <- data.frame(WilksDegreesofFreedom, Bartlett_ChiSq$wilks, Bartletts_p)
colnames(dfBartlett) <- c("Chi-Square Statistic", "Degrees of Freedom", "Wilks' Lambda", "p-value")
kable(data.frame("Chi-Square Statistic" = dfBartlett$`Chi-Square Statistic`,
"Degrees of Freedom" = dfBartlett$`Degrees of Freedom`,
"Wilks' Lambda" = dfBartlett$`Wilks' Lambda`,
"p-value" = Bartletts_p),
format="markdown", booktabs = T)  %>%
kable_styling(position = "center")
# MASS package used for qda()
df.numeric <- df.numeric[order(df.numeric$shot_made_flag),]
kobe.qda <- qda(shot_made_flag ~ ., CV=T, data=df.numeric)
qda(shot_made_flag ~ ., CV=T, data=df.numeric)
df.numeric <- df %>% keep(is.numeric) %>% mutate_if(is.integer, as.numeric)
# MASS package used for qda()
df.numeric <- df.numeric[order(df.numeric$shot_made_flag),]
kobe.qda <- qda(shot_made_flag ~ ., CV=T, data=df.numeric)
str(df.numeric)
df <- read.csv("./modelingKobeData.csv", header=T, sep=",", strip.white=T, stringsAsFactors = F, na.strings=c(""))
which(is.na(df$shot_zone_range))
df[which(df$action_type == "Alley Oop Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Cutting Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Finger Roll Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Reverse Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Finger Roll Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Follow Up Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Putback Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Putback Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Putback Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Reverse Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Reverse Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Reverse Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Finger Roll Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Reverse Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Tip Shot"),"action_type"] = "short"
df[which(df$action_type == "Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Tip Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Tip Shot"),"action_type"] = "short"
df$action_type <- ifelse(df$action_type=="short", "short", "long")
# shots with "Dunk", "Layup", or "Tip" are short:
df[which(df$combined_shot_type == "Dunk"),"combined_shot_type"] = "short"
df[which(df$combined_shot_type == "Layup"),"combined_shot_type"] = "short"
df[which(df$combined_shot_type == "Tip Shot"),"combined_shot_type"] = "short"
df$combined_shot_type <- ifelse(df$combined_shot_type=="short", "short", "far")
badNews <- "Sorry, but your math is off. If at first you don't succeed, try, try again. Don't give up too easily; persistence pays off in the end..."
tryCatch(
{
# Convert all integers to numeric and characters to factors with levels:
df <- df %>% mutate_if(is.integer, as.numeric) %>% mutate_if(is.character, as.factor) %>% data.frame()
df <- df %>%
subset(select=-c(team_id, # dropping since this is a uniform distribution of data
team_name, # dropping since this is a uniform distribution of data. Also collinear with team_id
action_type, # dropping this in favor of combined_shot_type
shot_zone_area, # this is ambiguous and less descriptive than geospatial data
shot_zone_basic, # this is ambiguous and less descriptive than geospatial data
shot_zone_range, # this is ambiguous and less descriptive than geospatial data
matchup # removing in favor of opponent; Kobe only played for LAL so that will never change
)
)
# create numeric dataframe for correlation plot
df.numeric <- df %>% keep(is.numeric)
},
error = function(e)
{
badNews
}
)
df[which(df$loc_y > 300),"shot_type"] <- "3PT Field Goal"
# Convert the points to integer values since they have integer value in reality
df$shot_type <- ifelse(df$shot_type=="2PT Field Goal", 2, 3)
corrplot::corrplot(cor(df.numeric %>% subset(select=-c(shot_made_flag)))
, title = "Correlation of Quantitative Predictor Variables, Before Variable Elimination"
, type = "lower"
, tl.pos = "ld"
, method = "square"
, tl.cex = 0.65
, tl.col = 'red'
, order = "alphabet"
, diag = F
, mar=c(0,0,5,0)
, bg="ivory1"
,tl.srt=.05
)
corrplot::corrplot(cor(df.numeric %>% subset(select=-c(shot_made_flag)))
, title = "Correlation of Quantitative Predictor Variables, Before Variable Elimination"
, type = "lower"
, tl.pos = "ld"
, method = "square"
, tl.cex = 0.65
, tl.col = 'red'
, order = "alphabet"
, diag = F
, mar=c(0,0,5,0)
, bg="ivory1"
,tl.srt=.05
)
df <- df %>% subset(select=-c(lat, # dropping lat because it is collinear with loc_y and shot_distance
lon, # dropping lon because it is collinear with loc_x and shot_distance
period, # dropping period in favor of game event id because game event id is more descriptive and continuous
playoffs # dropping playoffs for game_id; game ID can capture playoffs seasonally
)
)
df.numeric <- df %>% keep(is.numeric) %>% mutate_if(is.integer, as.numeric)
flattenCorrMatrix <- function(cormatrix, pmatrix) {
ut <- upper.tri(cormatrix)
data.frame(
row = rownames(cormatrix)[row(cormatrix)[ut]],
column = rownames(cormatrix)[col(cormatrix)[ut]],
cor  =(cormatrix)[ut],
p = pmatrix[ut]
)
}
options(scipen=999)
options(max.print=100000)
#See what variables are correlated with eachother, p-values
correlation.matrix <- Hmisc::rcorr(as.matrix(df.numeric), type="pearson")
corDF <- data.frame(flattenCorrMatrix(correlation.matrix$r, correlation.matrix$P))
corDF.ordered <- data.frame(corDF[order(-corDF$cor),])
collinear.correlation <- corDF[which(corDF$cor >= 0.50),]
collinear.correlation <- data.frame(collinear.correlation[order(-collinear.correlation$cor),])
collinear.correlation
#write.csv(colinear.correlation, "Collinear_Correlation_Matrix.csv")
#write.csv(corDF.ordered, "All_Vars_Correlation_Matrix.csv")
Bartlett_ChiSq <- rrcov::Wilks.test(shot_made_flag ~ ., data=df.numeric, method = "c", approximation = "Bartlett")
# Wilk's Lambda produces significant p-value in Bartlett's test so we need to use a Quadratic Discriminant Analysis instead of Linear
format(round(Bartlett_ChiSq$p.value, 2), nsmall=4)
# Wilks' Lambda plus degrees of freedom used in Bartlett's chi-squared test
WilksDegreesofFreedom <- rbind(as.numeric(paste0(Bartlett_ChiSq$parameter, sep = " ")))
# p-value from Bartlett's test
Bartlett_ChiSq$p.value
Bartletts_p <- format(round(as.numeric(Bartlett_ChiSq$p.value), 2), nsmall=4)
# Because Bartlett's p-value is less than 1, updating to shorter form:
Bartletts_p <- "p < 0.0001"
dfBartlett <- data.frame(WilksDegreesofFreedom, Bartlett_ChiSq$wilks, Bartletts_p)
colnames(dfBartlett) <- c("Chi-Square Statistic", "Degrees of Freedom", "Wilks' Lambda", "p-value")
kable(data.frame("Chi-Square Statistic" = dfBartlett$`Chi-Square Statistic`,
"Degrees of Freedom" = dfBartlett$`Degrees of Freedom`,
"Wilks' Lambda" = dfBartlett$`Wilks' Lambda`,
"p-value" = Bartletts_p),
format="markdown", booktabs = T)  %>%
kable_styling(position = "center")
df.numeric <- df.numeric[order(df.numeric$shot_made_flag),]
library(pacman)
p_load(rrcov, MASS, dplyr, purrr, ggplot2, Hmisc, pcaPP, knitr, kableExtra) #( Hmisc is for correlation matrix rcorr() )
# read in modeling data
df <- read.csv("./modelingKobeData.csv", header=T, sep=",", strip.white=T, stringsAsFactors = F, na.strings=c(""))
which(is.na(df$shot_zone_range))
df <- read.csv("./modelingKobeData.csv", header=T, sep=",", strip.white=T, stringsAsFactors = F, na.strings=c(""))
df[which(df$action_type == "Alley Oop Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Cutting Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Finger Roll Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Reverse Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Finger Roll Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Follow Up Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Putback Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Putback Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Putback Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Reverse Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Reverse Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Reverse Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Finger Roll Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Reverse Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Tip Shot"),"action_type"] = "short"
df[which(df$action_type == "Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Tip Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Tip Shot"),"action_type"] = "short"
df$action_type <- ifelse(df$action_type=="short", "short", "long")
# shots with "Dunk", "Layup", or "Tip" are short:
df[which(df$combined_shot_type == "Dunk"),"combined_shot_type"] = "short"
df[which(df$combined_shot_type == "Layup"),"combined_shot_type"] = "short"
df[which(df$combined_shot_type == "Tip Shot"),"combined_shot_type"] = "short"
df$combined_shot_type <- ifelse(df$combined_shot_type=="short", "short", "far")
badNews <- "Sorry, but your math is off. If at first you don't succeed, try, try again. Don't give up too easily; persistence pays off in the end..."
tryCatch(
{
# Convert all integers to numeric and characters to factors with levels:
df <- df %>% mutate_if(is.integer, as.numeric) %>% mutate_if(is.character, as.factor) %>% data.frame()
df <- df %>%
subset(select=-c(team_id, # dropping since this is a uniform distribution of data
team_name, # dropping since this is a uniform distribution of data. Also collinear with team_id
action_type, # dropping this in favor of combined_shot_type
shot_zone_area, # this is ambiguous and less descriptive than geospatial data
shot_zone_basic, # this is ambiguous and less descriptive than geospatial data
shot_zone_range, # this is ambiguous and less descriptive than geospatial data
matchup # removing in favor of opponent; Kobe only played for LAL so that will never change
)
)
# create numeric dataframe for correlation plot
df.numeric <- df %>% keep(is.numeric)
},
error = function(e)
{
badNews
}
)
badNews <- "Sorry, but your math is off. If at first you don't succeed, try, try again. Don't give up too easily; persistence pays off in the end..."
tryCatch(
{
# Convert all integers to numeric and characters to factors with levels:
df <- df %>% mutate_if(is.integer, as.numeric) %>% mutate_if(is.character, as.factor) %>% data.frame()
df <- df %>%
subset(select=-c(team_id, # dropping since this is a uniform distribution of data
team_name, # dropping since this is a uniform distribution of data. Also collinear with team_id
action_type, # dropping this in favor of combined_shot_type
shot_zone_area, # this is ambiguous and less descriptive than geospatial data
shot_zone_basic, # this is ambiguous and less descriptive than geospatial data
shot_zone_range, # this is ambiguous and less descriptive than geospatial data
matchup # removing in favor of opponent; Kobe only played for LAL so that will never change
)
)
# create numeric dataframe for correlation plot
df.numeric <- df %>% keep(is.numeric)
},
error = function(e)
{
badNews
}
)
df[which(df$loc_y > 300),"shot_type"] <- "3PT Field Goal"
# Convert the points to integer values since they have integer value in reality
df$shot_type <- ifelse(df$shot_type=="2PT Field Goal", 2, 3)
corrplot::corrplot(cor(df.numeric %>% subset(select=-c(shot_made_flag)))
, title = "Correlation of Quantitative Predictor Variables, Before Variable Elimination"
, type = "lower"
, tl.pos = "ld"
, method = "square"
, tl.cex = 0.65
, tl.col = 'red'
, order = "alphabet"
, diag = F
, mar=c(0,0,5,0)
, bg="ivory1"
,tl.srt=.05
)
df <- df %>% subset(select=-c(lat, # dropping lat because it is collinear with loc_y and shot_distance
lon, # dropping lon because it is collinear with loc_x and shot_distance
period, # dropping period in favor of game event id because game event id is more descriptive and continuous
playoffs # dropping playoffs for game_id; game ID can capture playoffs seasonally
)
)
df.numeric <- df %>% keep(is.numeric) %>% mutate_if(is.integer, as.numeric)
flattenCorrMatrix <- function(cormatrix, pmatrix) {
ut <- upper.tri(cormatrix)
data.frame(
row = rownames(cormatrix)[row(cormatrix)[ut]],
column = rownames(cormatrix)[col(cormatrix)[ut]],
cor  =(cormatrix)[ut],
p = pmatrix[ut]
)
}
options(scipen=999)
options(max.print=100000)
#See what variables are correlated with eachother, p-values
correlation.matrix <- Hmisc::rcorr(as.matrix(df.numeric), type="pearson")
corDF <- data.frame(flattenCorrMatrix(correlation.matrix$r, correlation.matrix$P))
corDF.ordered <- data.frame(corDF[order(-corDF$cor),])
collinear.correlation <- corDF[which(corDF$cor >= 0.50),]
collinear.correlation <- data.frame(collinear.correlation[order(-collinear.correlation$cor),])
collinear.correlation
#write.csv(colinear.correlation, "Collinear_Correlation_Matrix.csv")
#write.csv(corDF.ordered, "All_Vars_Correlation_Matrix.csv")
Bartlett_ChiSq <- rrcov::Wilks.test(shot_made_flag ~ ., data=df.numeric, method = "c", approximation = "Bartlett")
# Wilk's Lambda produces significant p-value in Bartlett's test so we need to use a Quadratic Discriminant Analysis instead of Linear
format(round(Bartlett_ChiSq$p.value, 2), nsmall=4)
# Wilks' Lambda plus degrees of freedom used in Bartlett's chi-squared test
WilksDegreesofFreedom <- rbind(as.numeric(paste0(Bartlett_ChiSq$parameter, sep = " ")))
# p-value from Bartlett's test
Bartlett_ChiSq$p.value
Bartletts_p <- format(round(as.numeric(Bartlett_ChiSq$p.value), 2), nsmall=4)
# Because Bartlett's p-value is less than 1, updating to shorter form:
Bartletts_p <- "p < 0.0001"
dfBartlett <- data.frame(WilksDegreesofFreedom, Bartlett_ChiSq$wilks, Bartletts_p)
colnames(dfBartlett) <- c("Chi-Square Statistic", "Degrees of Freedom", "Wilks' Lambda", "p-value")
kable(data.frame("Chi-Square Statistic" = dfBartlett$`Chi-Square Statistic`,
"Degrees of Freedom" = dfBartlett$`Degrees of Freedom`,
"Wilks' Lambda" = dfBartlett$`Wilks' Lambda`,
"p-value" = Bartletts_p),
format="markdown", booktabs = T)  %>%
kable_styling(position = "center")
qda(shot_made_flag ~ ., CV=T, data=df.numeric)
kobe.qda <- qda(shot_made_flag ~ ., CV=T, data=df.numeric)
kobe.qda <- qda(shot_made_flag ~ ., CV=T, data=df.numeric)
qda(shot_made_flag ~ ., CV=T, data=df.numeric)
kobe.qda <- qda(shot_made_flag ~ ., CV=T, data=df.numeric)
kobe.qda
# MASS package used for qda()
#df.numeric <- df.numeric[order(df.numeric$shot_made_flag),]
kobe.qda <- qda(shot_made_flag ~ ., CV=T, data=df.numeric)
str(df.numeric)
data.frame(mean(kobe.qda$posterior[,1]), mean(kobe.qda$posterior[,2]))
shot_made_flagg <- rbind("0", "1")
proportion <- rbind(mean(kobe.qda$posterior[,1]), mean(kobe.qda$posterior[,2]))
data.frame(shot_made_flagg, proportion) # Class Level Information
#caret::confusionMatrix(table(kobe.qda$posterior[,1], dfKobe$shot_made_flag))
#qda.pred <- predict(kobe.qda)$class
data.frame(mean(kobe.qda$posterior[,1]), mean(kobe.qda$posterior[,2]))
summary(back.glm)
df <- read.csv("./modelingKobeData.csv", header=T, sep=",", strip.white=T, stringsAsFactors = F, na.strings=c(""))
df[which(df$action_type == "Alley Oop Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Cutting Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Finger Roll Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Reverse Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Driving Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Finger Roll Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Follow Up Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Putback Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Putback Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Putback Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Reverse Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Reverse Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Reverse Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Finger Roll Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Reverse Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Running Tip Shot"),"action_type"] = "short"
df[which(df$action_type == "Slam Dunk Shot"),"action_type"] = "short"
df[which(df$action_type == "Tip Layup Shot"),"action_type"] = "short"
df[which(df$action_type == "Tip Shot"),"action_type"] = "short"
df$action_type <- ifelse(df$action_type=="short", "short", "long")
# shots with "Dunk", "Layup", or "Tip" are short:
df[which(df$combined_shot_type == "Dunk"),"combined_shot_type"] = "short"
df[which(df$combined_shot_type == "Layup"),"combined_shot_type"] = "short"
df[which(df$combined_shot_type == "Tip Shot"),"combined_shot_type"] = "short"
df$combined_shot_type <- ifelse(df$combined_shot_type=="short", "short", "far")
badNews <- "Sorry, but your math is off and the transformations were not performed. Please update and try again."
tryCatch(
{
# Convert all integers to numeric and characters to factors with levels:
df <- df %>% mutate_if(is.integer, as.numeric) %>% mutate_if(is.character, as.factor) %>% data.frame()
df <- df %>%
subset(select=-c(team_id, # dropping since this is a uniform distribution of data
team_name, # dropping since this is a uniform distribution of data. Also collinear with team_id
action_type, # dropping this in favor of combined_shot_type
shot_zone_area, # this is ambiguous and less descriptive than geospatial data
shot_zone_basic, # this is ambiguous and less descriptive than geospatial data
shot_zone_range, # this is ambiguous and less descriptive than geospatial data
matchup # removing in favor of opponent; Kobe only played for LAL so that will never change
)
)
# create numeric dataframe for correlation plot
df.numeric <- df %>% keep(is.numeric)
},
error = function(e)
{
badNews
}
)
df[which(df$loc_y > 300),"shot_type"] <- "3PT Field Goal"
# Convert the points to integer values since they have integer value in reality
df$shot_type <- ifelse(df$shot_type=="2PT Field Goal", 2, 3)
df <- df %>% subset(select=-c(lat, # dropping lat because it is collinear with loc_y and shot_distance
lon, # dropping lon because it is collinear with loc_x and shot_distance
period, # dropping period in favor of game event id because game event id is more descriptive and continuous
playoffs # dropping playoffs for game_id; game ID can capture playoffs seasonally
)
)
df.numeric <- df %>% keep(is.numeric) %>% mutate_if(is.integer, as.numeric)
flattenCorrMatrix <- function(cormatrix, pmatrix) {
ut <- upper.tri(cormatrix)
data.frame(
row = rownames(cormatrix)[row(cormatrix)[ut]],
column = rownames(cormatrix)[col(cormatrix)[ut]],
cor  =(cormatrix)[ut],
p = pmatrix[ut]
)
}
options(scipen=999)
options(max.print=100000)
#See what variables are correlated with eachother, p-values
correlation.matrix <- Hmisc::rcorr(as.matrix(df.numeric), type="pearson")
corDF <- data.frame(flattenCorrMatrix(correlation.matrix$r, correlation.matrix$P))
corDF.ordered <- data.frame(corDF[order(-corDF$cor),])
collinear.correlation <- corDF[which(corDF$cor >= 0.50),]
collinear.correlation <- data.frame(collinear.correlation[order(-collinear.correlation$cor),])
collinear.correlation
Bartlett_ChiSq <- rrcov::Wilks.test(shot_made_flag ~ ., data=df.numeric, method = "c", approximation = "Bartlett")
# Wilk's Lambda produces significant p-value in Bartlett's test so we need to use a Quadratic Discriminant Analysis instead of Linear
format(round(Bartlett_ChiSq$p.value, 2), nsmall=4)
# Wilks' Lambda plus degrees of freedom used in Bartlett's chi-squared test
WilksDegreesofFreedom <- rbind(as.numeric(paste0(Bartlett_ChiSq$parameter, sep = " ")))
# p-value from Bartlett's test
Bartlett_ChiSq$p.value
Bartletts_p <- format(round(as.numeric(Bartlett_ChiSq$p.value), 2), nsmall=4)
# Because Bartlett's p-value is less than 1, updating to shorter form:
Bartletts_p <- "p < 0.0001"
dfBartlett <- data.frame(WilksDegreesofFreedom, Bartlett_ChiSq$wilks, Bartletts_p)
colnames(dfBartlett) <- c("Chi-Square Statistic", "Degrees of Freedom", "Wilks' Lambda", "p-value")
kobe.qda <- qda(shot_made_flag ~ ., CV=T, data=df.numeric)
data.frame(mean(kobe.qda$posterior[,1]), mean(kobe.qda$posterior[,2]))
shot_made_flagg <- rbind("0", "1")
proportion <- rbind(mean(kobe.qda$posterior[,1]), mean(kobe.qda$posterior[,2]))
data.frame(shot_made_flagg, proportion) # Class Level Information
model.forward.Start <- glm(shot_made_flag~1, family=binomial(link='logit'), data = df)
model.Allvar <- glm(shot_made_flag ~ recId + combined_shot_type + game_event_id + game_id + loc_x + loc_y +
minutes_remaining + season + seconds_remaining + shot_distance + shot_type + game_date +
opponent + shot_id + attendance + arena_temp + avgnoisedb, family=binomial(link='logit'), data = df)
model.Forward <- stepAIC(model.forward.Start, direction = "forward", trace = F, scope = formula(model.Allvar))
